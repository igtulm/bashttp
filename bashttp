#!/bin/bash

source libs/console

source config
source routes


fdebug() { if [ ${config[is_debugging]} -eq 1 ]; then echo "$@" >> "${config[debug_file]}"; fi }

start() {
    local script_path=$0
    fdebug $script_path

    console__info "Starting server on ${config[ip]}:${config[port]}"

    tcpserver "${config[ip]}" "${config[port]}" "./$script_path" connection_handler
}

# SERVER constants
SERVER_HTTP_PROTOCOL="HTTP/1.1"
declare -A SERVER_REQUEST_METHODS=(
    [HEAD]=HEAD
    [GET]=GET
    [POST]=POST
    [PUT]=PUT
    [DELETE]=DELETE
)

declare -A SERVER_RESPONSES=(
    [200]=OK
    [400]="Bad Request"
    [401]=Unauthorized
    [403]=Forbidden
    [404]="Not Found"
    [405]="Method Not Allowed"
    [500]="Internal Server Error"
)

# REQUEST vars
REQUEST_METHOD=
REQUEST_ROUTE=
REQUEST_PROTOCOL=
declare -A REQUEST_HEADERS
REQUEST_BODY=


# RESPONSE vars
declare -A RESPONSE_HEADERS
RESPONSE_CODE=404
RESPONSE_MESSAGE_BODY=


request() {
    fdebug "Request begin"

    # Read start line
    read -t "${config[timeout]}" -r request_start_line

    local start_line="$(echo $request_start_line| tr -d '\r')"
    if (($(echo $start_line | wc -w) != 3)); then
        fdebug "400 (Bad Request)"

        response 400

        exit 0
    fi

    REQUEST_PROTOCOL="$(echo $start_line| cut -d ' ' -f 3)"
    if [ $REQUEST_PROTOCOL != $SERVER_HTTP_PROTOCOL ]; then
        fdebug "400 (Bad Request)"
        
        response 400

        exit 0
    fi

    REQUEST_METHOD="$(echo $start_line| cut -d ' ' -f 1)"
    if [ ! ${SERVER_REQUEST_METHODS[$REQUEST_METHOD]} ]; then
        fdebug "405 (Method Not Allowed)"

        response 405

        exit 0
    fi

    REQUEST_ROUTE="$(echo $start_line| cut -d ' ' -f 2| tr /A-Z/ /a-z/)"

    fdebug "route: $REQUEST_ROUTE"
    fdebug "method: $REQUEST_METHOD"
    fdebug "protocol: $REQUEST_PROTOCOL"


    # Read headers
    while read -t "${config[timeout]}" -r request_header; do
        header="$(echo $request_header| tr -d '\r')"

        # break on empty string
        [ -z "$header" ] && break

        header_key="$(echo $header| cut -d ':' -f 1)"
        header_value="$(echo $header| cut -d ' ' -f 2-)"

        REQUEST_HEADERS[$header_key]=$header_value

        fdebug "header: [$header_key]=$header_value"
    done

    # Read message-body if Content-Length header is presented
    if [ ${REQUEST_HEADERS[Content-Length]} ]; then
        # Read message-body to buffer
        read -t "${config[timeout]}" -r request_body

        # Cut data from buffer with length specified
        REQUEST_BODY="$(printf "%s" $REQUEST_BODY| tr -d '\r'| cut -c -${REQUEST_HEADERS[Content-Length]})"

        fdebug "body: $REQUEST_BODY"
    fi

    fdebug "Request end"
}

throw_json_msg_by_code() {
    local status_code=$1

    RESPONSE_HEADERS[Content-Type]="application/json"
    RESPONSE_MESSAGE_BODY="$(printf "{code: %d, message: %s}" "$status_code" "${SERVER_RESPONSES[$status_code]}")"

    setContentLength
}

response() {
    local status_code=$1
    # if [ ! ${SERVER_RESPONSES[$status_code]} ]; then
    #     status_code=500
    # fi

    local status_line="$(printf "%s %u %s" "$SERVER_HTTP_PROTOCOL" "$status_code" "${SERVER_RESPONSES[$status_code]}")"
    RESPONSE_HEADERS[Server]="${config[server_name]}"
    RESPONSE_HEADERS[Date]="$(console__datetime)"
    RESPONSE_HEADERS[Connection]=close

    # todo if lt 200 and gt 299
    if [ $status_code -ne 200 ]; then
        throw_json_msg_by_code $status_code
    fi

    # send response
    echo -n "$status_line"
    echo -en "\r\n"
    local response_headers_string=""
    for key in "${!RESPONSE_HEADERS[@]}"; do
        echo -en "$key: "${RESPONSE_HEADERS["$key"]}"\r\n"
        response_headers_string+="$key: "${RESPONSE_HEADERS["$key"]}"; "
    done
    echo -en "\r\n"
    echo -n "$RESPONSE_MESSAGE_BODY"
    echo -en "\r\n"

    fdebug "Response begin"
    fdebug "status-line: $status_line"
    fdebug "headers: $response_headers_string"
    fdebug "message-body: $RESPONSE_MESSAGE_BODY"
    fdebug "Response end"
}

try_route() {
    # To do
    return -1
}

setFileMesageBody() {
    RESPONSE_MESSAGE_BODY="$(<"$1")"
}

setContentLength() {
    RESPONSE_HEADERS[Content-Length]="$(echo -n "$RESPONSE_MESSAGE_BODY"| wc -c)"
}

setFileContentType() {
    local extension="$(basename $1| rev | cut -d . -f 1 | rev)"

    # todo images fonts etc
    case "$extension" in
        css) type="text/css" ;;
        js) type="text/javascript" ;;
        json) type="application/json" ;;
        *) type="$<(file -b --mime-type "$1")" ;;
    esac

    RESPONSE_HEADERS[Content-Type]=type
}

try_file() {
    local root="${config[web_root]}"
    local path="$REQUEST_ROUTE"

    local target="$root$path"

    if [ -d $target ]; then
        target+="/index.html"
    fi

    if [ -f $target ]; then
        setFileMesageBody "$target"
        setFileContentType "$target"
        setContentLength
        
        RESPONSE_CODE=200

        return
    fi

    return -1
}

connection_handler() {
    request
    try_route || try_file
    response $RESPONSE_CODE
}

$@
